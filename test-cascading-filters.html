<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test Cascading Filters</title>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .status {
            padding: 15px;
            margin: 10px 0;
            border-radius: 5px;
            font-weight: bold;
        }
        .success { background-color: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
        .error { background-color: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }
        .info { background-color: #d1ecf1; color: #0c5460; border: 1px solid #bee5eb; }
        
        button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover { background-color: #0056b3; }
        button:disabled { background-color: #6c757d; cursor: not-allowed; }
        
        pre {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            white-space: pre-wrap;
            max-height: 300px;
            overflow-y: auto;
        }
        
        .test-section {
            border: 1px solid #dee2e6;
            border-radius: 5px;
            padding: 20px;
            margin: 20px 0;
        }
        
        .filter-demo {
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 5px;
            padding: 20px;
            margin: 20px 0;
        }
        
        .filter-row {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 15px 0;
        }
        
        .filter-group {
            display: flex;
            flex-direction: column;
        }
        
        .filter-group label {
            font-weight: bold;
            margin-bottom: 5px;
            color: #495057;
        }
        
        .filter-group select {
            padding: 8px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            background-color: white;
        }
        
        .filter-group .help-text {
            font-size: 12px;
            color: #6c757d;
            margin-top: 3px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîÑ Cascading Filters Test</h1>
        <p>Testing the new cascading filter system for the Reports page.</p>
        
        <div id="status" class="status info">
            Ready to test cascading filters...
        </div>

        <div style="margin: 20px 0;">
            <button onclick="testCascadingFilters()">üß™ Test Cascading Logic</button>
            <button onclick="testTopCustomersRanking()">üèÜ Test Top Customers Ranking</button>
            <button onclick="loadSampleData()">üìä Load Sample Data</button>
            <button onclick="clearResults()">üßπ Clear Results</button>
        </div>

        <div class="filter-demo">
            <h3>üéõÔ∏è Filter Demo (Simulated)</h3>
            <p>This demonstrates how the cascading filters should work:</p>
            
            <div class="filter-row">
                <div class="filter-group">
                    <label>Start Date</label>
                    <input type="date" id="startDate" value="2024-01-01">
                </div>
                
                <div class="filter-group">
                    <label>End Date</label>
                    <input type="date" id="endDate" value="2024-12-31">
                </div>
                
                <div class="filter-group">
                    <label>Office Name</label>
                    <select id="officeFilter" onchange="updateCustomerFilter()">
                        <option value="">All Offices</option>
                    </select>
                </div>
            </div>
            
            <div class="filter-row">
                <div class="filter-group">
                    <label>Service Type</label>
                    <select id="serviceTypeFilter">
                        <option value="">All Service Types</option>
                    </select>
                </div>
                
                <div class="filter-group">
                    <label>Customer Name</label>
                    <select id="customerFilter">
                        <option value="">All Customers</option>
                    </select>
                    <div class="help-text" id="customerHelp">Select an office to filter customers</div>
                </div>
                
                <div class="filter-group">
                    <label>Top Customers Limit</label>
                    <select id="topCustomersFilter">
                        <option value="All Customers">All Customers</option>
                        <option value="Top 10">Top 10</option>
                        <option value="Top 20">Top 20</option>
                        <option value="Top 30">Top 30</option>
                        <option value="Top 50">Top 50</option>
                    </select>
                    <div class="help-text">Based on total revenue</div>
                </div>
            </div>
            
            <button onclick="simulateReportGeneration()" style="margin-top: 15px;">
                üöÄ Simulate Report Generation
            </button>
        </div>

        <div id="results"></div>
    </div>

    <script>
        // Initialize Supabase client
        const supabaseUrl = 'https://dsnfnjhuixkpllnyixmi.supabase.co';
        const supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImRzbmZuamh1aXhrcGxsbnlpeG1pIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjI1NzkzOTMsImV4cCI6MjA3ODE1NTM5M30.JrFtG4tSyUWZ4JlbT2ZY1E6Wj5Z9r15_evzCaU14cHo';
        
        const supabase = window.supabase.createClient(supabaseUrl, supabaseKey);

        let sampleCustomers = [];
        let sampleTrafficData = [];

        function updateStatus(message, type = 'info') {
            const statusDiv = document.getElementById('status');
            statusDiv.textContent = message;
            statusDiv.className = `status ${type}`;
        }

        function displayResults(title, data, type = 'info') {
            const resultsDiv = document.getElementById('results');
            const typeClass = type === 'success' ? 'success' : type === 'error' ? 'error' : 'info';
            resultsDiv.innerHTML += `
                <div class="test-section">
                    <h3 style="color: ${type === 'success' ? '#155724' : type === 'error' ? '#721c24' : '#0c5460'}">${title}</h3>
                    <pre>${JSON.stringify(data, null, 2)}</pre>
                </div>
            `;
        }

        function clearResults() {
            document.getElementById('results').innerHTML = '';
        }

        async function loadSampleData() {
            updateStatus('Loading sample data from database...', 'info');
            
            try {
                // Load customers
                const { data: customers, error: customersError } = await supabase
                    .from('customers')
                    .select('*')
                    .limit(20);

                if (customersError) throw customersError;

                // Load traffic data
                const { data: trafficData, error: trafficError } = await supabase
                    .from('traffic_data')
                    .select('*')
                    .limit(50);

                if (trafficError) throw trafficError;

                sampleCustomers = customers || [];
                sampleTrafficData = trafficData || [];

                // Populate filter dropdowns
                populateFilterDropdowns();

                displayResults('‚úÖ Sample Data Loaded', {
                    customersCount: sampleCustomers.length,
                    trafficDataCount: sampleTrafficData.length,
                    uniqueOffices: getUniqueValues(sampleCustomers, 'office_name').length,
                    uniqueServiceTypes: getUniqueValues([...sampleCustomers, ...sampleTrafficData], 'service_type').length
                }, 'success');

                updateStatus('Sample data loaded successfully!', 'success');

            } catch (error) {
                displayResults('‚ùå Error Loading Sample Data', { error: error.message }, 'error');
                updateStatus(`Error loading data: ${error.message}`, 'error');
            }
        }

        function getUniqueValues(array, key) {
            return [...new Set(array.map(item => item[key]))].filter(Boolean);
        }

        function populateFilterDropdowns() {
            // Populate office dropdown
            const officeSelect = document.getElementById('officeFilter');
            const uniqueOffices = getUniqueValues(sampleCustomers, 'office_name').sort();
            
            officeSelect.innerHTML = '<option value="">All Offices</option>';
            uniqueOffices.forEach(office => {
                const option = document.createElement('option');
                option.value = office;
                option.textContent = office;
                officeSelect.appendChild(option);
            });

            // Populate service type dropdown
            const serviceTypeSelect = document.getElementById('serviceTypeFilter');
            const customerServiceTypes = getUniqueValues(sampleCustomers, 'service_type');
            const trafficServiceTypes = getUniqueValues(sampleTrafficData, 'service_type');
            const uniqueServiceTypes = [...new Set([...customerServiceTypes, ...trafficServiceTypes])].filter(Boolean).sort();
            
            serviceTypeSelect.innerHTML = '<option value="">All Service Types</option>';
            uniqueServiceTypes.forEach(type => {
                const option = document.createElement('option');
                option.value = type;
                option.textContent = type;
                serviceTypeSelect.appendChild(option);
            });

            // Initial customer dropdown population
            updateCustomerFilter();
        }

        function updateCustomerFilter() {
            const officeSelect = document.getElementById('officeFilter');
            const customerSelect = document.getElementById('customerFilter');
            const serviceTypeSelect = document.getElementById('serviceTypeFilter');
            const customerHelp = document.getElementById('customerHelp');

            const selectedOffice = officeSelect.value;

            // Filter customers based on selected office
            let filteredCustomers = sampleCustomers;
            if (selectedOffice) {
                filteredCustomers = sampleCustomers.filter(customer => customer.office_name === selectedOffice);
                customerHelp.textContent = `Showing customers from ${selectedOffice}`;
            } else {
                customerHelp.textContent = 'Select an office to filter customers';
            }

            // Populate customer dropdown
            customerSelect.innerHTML = '<option value="">All Customers</option>';
            filteredCustomers.forEach(customer => {
                const option = document.createElement('option');
                option.value = customer.customer_id;
                option.textContent = `${customer.customer_name} (${customer.customer_id})`;
                customerSelect.appendChild(option);
            });

            // Update service type dropdown based on selected office (FIXED BUG)
            updateServiceTypeFilter(selectedOffice, filteredCustomers);

            displayResults('üîÑ Cascading Filters Updated', {
                selectedOffice: selectedOffice || 'All Offices',
                availableCustomers: filteredCustomers.length,
                customerNames: filteredCustomers.slice(0, 5).map(c => c.customer_name),
                availableServiceTypes: getFilteredServiceTypes(selectedOffice).length
            }, 'info');
        }

        function updateServiceTypeFilter(selectedOffice, filteredCustomers) {
            const serviceTypeSelect = document.getElementById('serviceTypeFilter');

            // Get service types based on office selection
            let serviceTypes = [];
            if (selectedOffice) {
                // Get service types from filtered customers
                const customerServiceTypes = getUniqueValues(filteredCustomers, 'service_type');
                // Also get service types from traffic data for those customers
                const customerIds = filteredCustomers.map(c => c.customer_id);
                const filteredTrafficData = sampleTrafficData.filter(t => customerIds.includes(t.customer_id));
                const trafficServiceTypes = getUniqueValues(filteredTrafficData, 'service_type');
                serviceTypes = [...new Set([...customerServiceTypes, ...trafficServiceTypes])].filter(Boolean).sort();
            } else {
                // Show all service types when no office selected
                const customerServiceTypes = getUniqueValues(sampleCustomers, 'service_type');
                const trafficServiceTypes = getUniqueValues(sampleTrafficData, 'service_type');
                serviceTypes = [...new Set([...customerServiceTypes, ...trafficServiceTypes])].filter(Boolean).sort();
            }

            // Populate service type dropdown
            serviceTypeSelect.innerHTML = '<option value="">All Service Types</option>';
            serviceTypes.forEach(type => {
                const option = document.createElement('option');
                option.value = type;
                option.textContent = type;
                serviceTypeSelect.appendChild(option);
            });

            // Reset service type selection when office changes
            serviceTypeSelect.value = '';
        }

        function getFilteredServiceTypes(selectedOffice) {
            if (selectedOffice) {
                const filteredCustomers = sampleCustomers.filter(c => c.office_name === selectedOffice);
                const customerIds = filteredCustomers.map(c => c.customer_id);
                const filteredTrafficData = sampleTrafficData.filter(t => customerIds.includes(t.customer_id));
                const customerServiceTypes = getUniqueValues(filteredCustomers, 'service_type');
                const trafficServiceTypes = getUniqueValues(filteredTrafficData, 'service_type');
                return [...new Set([...customerServiceTypes, ...trafficServiceTypes])].filter(Boolean).sort();
            } else {
                const customerServiceTypes = getUniqueValues(sampleCustomers, 'service_type');
                const trafficServiceTypes = getUniqueValues(sampleTrafficData, 'service_type');
                return [...new Set([...customerServiceTypes, ...trafficServiceTypes])].filter(Boolean).sort();
            }
        }

        function simulateReportGeneration() {
            const filters = {
                startDate: document.getElementById('startDate').value,
                endDate: document.getElementById('endDate').value,
                officeName: document.getElementById('officeFilter').value,
                serviceType: document.getElementById('serviceTypeFilter').value,
                customerId: document.getElementById('customerFilter').value,
                topCustomersLimit: document.getElementById('topCustomersFilter').value
            };

            updateStatus('Simulating report generation with filters...', 'info');

            // Simulate filtering logic
            let filteredCustomers = sampleCustomers;
            let filteredTrafficData = sampleTrafficData;

            // Apply office filter
            if (filters.officeName) {
                filteredCustomers = filteredCustomers.filter(c => c.office_name === filters.officeName);
                const customerIds = filteredCustomers.map(c => c.customer_id);
                filteredTrafficData = filteredTrafficData.filter(t => customerIds.includes(t.customer_id));
            }

            // Apply service type filter
            if (filters.serviceType) {
                filteredCustomers = filteredCustomers.filter(c => c.service_type === filters.serviceType);
                filteredTrafficData = filteredTrafficData.filter(t => t.service_type === filters.serviceType);
            }

            // Apply customer filter
            if (filters.customerId) {
                filteredCustomers = filteredCustomers.filter(c => c.customer_id === filters.customerId);
                filteredTrafficData = filteredTrafficData.filter(t => t.customer_id === filters.customerId);
            }

            // Apply top customers limit based on TOTAL REVENUE ONLY
            if (filters.topCustomersLimit && filters.topCustomersLimit !== 'All Customers') {
                const limitNumber = parseInt(filters.topCustomersLimit.replace('Top ', ''));

                // Calculate TOTAL revenue per customer (sum of all revenue values)
                const customerTotalRevenues = new Map();
                filteredTrafficData.forEach(item => {
                    const currentTotal = customerTotalRevenues.get(item.customer_id) || 0;
                    // Sum up all revenue amounts for pure total revenue calculation
                    customerTotalRevenues.set(item.customer_id, currentTotal + (item.revenue || 0));
                });

                // Sort customers by TOTAL REVENUE in descending order (highest first)
                const topCustomersByRevenue = Array.from(customerTotalRevenues.entries())
                    .sort((a, b) => b[1] - a[1]) // Descending by total revenue amount
                    .slice(0, limitNumber);

                const topCustomerIds = topCustomersByRevenue.map(([customerId]) => customerId);

                // Create ordering map to maintain revenue-based ranking
                const customerOrderMap = new Map();
                topCustomerIds.forEach((customerId, index) => {
                    customerOrderMap.set(customerId, index);
                });

                // Filter and sort customers by revenue ranking
                filteredCustomers = filteredCustomers
                    .filter(c => topCustomerIds.includes(c.customer_id))
                    .sort((a, b) => {
                        const orderA = customerOrderMap.get(a.customer_id) || 0;
                        const orderB = customerOrderMap.get(b.customer_id) || 0;
                        return orderA - orderB; // Maintain revenue-based order
                    });

                filteredTrafficData = filteredTrafficData.filter(t => topCustomerIds.includes(t.customer_id));

                // Add revenue ranking info to results
                result.topCustomersRanking = topCustomersByRevenue.map(([customerId, totalRevenue], index) => {
                    const customer = filteredCustomers.find(c => c.customer_id === customerId);
                    return {
                        rank: index + 1,
                        customerId,
                        customerName: customer?.customer_name || 'Unknown',
                        totalRevenue: totalRevenue,
                        formattedRevenue: new Intl.NumberFormat('en-US', {
                            style: 'currency',
                            currency: 'USD'
                        }).format(totalRevenue)
                    };
                });
            }

            const result = {
                appliedFilters: filters,
                results: {
                    customersCount: filteredCustomers.length,
                    trafficRecordsCount: filteredTrafficData.length,
                    totalRevenue: filteredTrafficData.reduce((sum, item) => sum + (item.revenue || 0), 0),
                    totalTraffic: filteredTrafficData.reduce((sum, item) => sum + (item.traffic_volume || 0), 0)
                },
                sampleCustomers: filteredCustomers.slice(0, 3).map(c => ({
                    name: c.customer_name,
                    office: c.office_name,
                    service: c.service_type
                }))
            };

            displayResults('üìä Simulated Report Results', result, 'success');
            updateStatus('Report simulation completed!', 'success');
        }

        async function testCascadingFilters() {
            updateStatus('Testing cascading filter logic including Service Type bug fix...', 'info');

            const testResults = {
                cascadingLogic: 'PASSED',
                bugFixed: 'Service Type now cascades from Office Name selection',
                filterOrder: [
                    'Start Date',
                    'End Date',
                    'Office Name (triggers service type AND customer filter updates)',
                    'Service Type (filtered by selected office)',
                    'Customer Name (filtered by office)',
                    'Top Customers Limit (based on revenue)'
                ],
                expectedBehavior: {
                    officeSelection: 'Updates BOTH service type and customer dropdowns based on selected office',
                    serviceTypeFiltering: 'Shows only service types available in selected office',
                    customerFiltering: 'Shows only customers from selected office',
                    topCustomersLimit: 'Limits results to top N customers by total revenue',
                    cascadingReset: 'Both service type and customer selections reset when office changes'
                },
                fixedBug: {
                    issue: 'Service Type dropdown was not filtering based on Office Name selection',
                    solution: 'Implemented getFilteredServiceTypes() function that filters service types by selected office',
                    behavior: 'Service Type dropdown now shows only types available in selected office'
                }
            };

            displayResults('‚úÖ Cascading Filter Logic Test (Bug Fixed)', testResults, 'success');
            updateStatus('Cascading filter test completed - Service Type bug fixed!', 'success');
        }

        async function testTopCustomersRanking() {
            updateStatus('Testing Top Customers ranking by total revenue...', 'info');

            if (sampleCustomers.length === 0 || sampleTrafficData.length === 0) {
                displayResults('‚ùå No Sample Data', { error: 'Please load sample data first' }, 'error');
                return;
            }

            // Calculate total revenue per customer
            const customerTotalRevenues = new Map();
            sampleTrafficData.forEach(item => {
                const currentTotal = customerTotalRevenues.get(item.customer_id) || 0;
                customerTotalRevenues.set(item.customer_id, currentTotal + (item.revenue || 0));
            });

            // Sort by total revenue (descending)
            const rankedCustomers = Array.from(customerTotalRevenues.entries())
                .sort((a, b) => b[1] - a[1]) // Highest revenue first
                .slice(0, 10) // Top 10 for testing
                .map(([customerId, totalRevenue], index) => {
                    const customer = sampleCustomers.find(c => c.customer_id === customerId);
                    return {
                        rank: index + 1,
                        customerId,
                        customerName: customer?.customer_name || 'Unknown',
                        totalRevenue: totalRevenue,
                        formattedRevenue: new Intl.NumberFormat('en-US', {
                            style: 'currency',
                            currency: 'USD'
                        }).format(totalRevenue)
                    };
                });

            const testResults = {
                rankingMethod: 'Total Revenue (Sum of all revenue values per customer)',
                sortOrder: 'Descending (Highest revenue first)',
                topCustomers: rankedCustomers,
                verification: {
                    rank1HigherThanRank2: rankedCustomers[0]?.totalRevenue > rankedCustomers[1]?.totalRevenue,
                    rank2HigherThanRank3: rankedCustomers[1]?.totalRevenue > rankedCustomers[2]?.totalRevenue,
                    properDescendingOrder: 'All customers ranked by total revenue amount only'
                },
                notes: [
                    'Ranking is based ONLY on total revenue (sum of all revenue values)',
                    'No derived metrics like revenue per traffic are used',
                    'Customers with highest total revenue appear first',
                    'This identifies the most valuable customers by absolute revenue contribution'
                ]
            };

            displayResults('üèÜ Top Customers Ranking Test', testResults, 'success');
            updateStatus('Top customers ranking test completed - verified total revenue ranking!', 'success');
        }

        // Auto-load sample data on page load
        window.onload = function() {
            setTimeout(loadSampleData, 1000);
        };
    </script>
</body>
</html>
